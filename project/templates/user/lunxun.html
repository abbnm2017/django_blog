{% extends 'user/three_base.html' %}
{% load static %}


{% block content %}
    <blockquote class="blockquote text-center">
      <p class="mb-0" style="color: yellowgreen">轮询,长轮询,websocket之间的关联</p>
      <footer class="blockquote-footer">designer keke <cite title="Source Title">轮询 or 长轮询 or socket</cite></footer>
    </blockquote>
    <div style="margin-left: 20px">


        <h3>轮询</h3>
        <p>
            短轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。
            这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接收请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地
            收到服务器端的数据的变化。
        </p>

        <p>
           这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，
            严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级相对比较大的人同时位于基于短轮询的应用中，那么每一个用户的
            客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。
        </p>

        <p>
            因此短轮询不适用于那些同事在线用户数量比较大，并且很注重性能的Web应用。
        </p>

        <pre>
            var xhr = new XMLHttpRequest();
            setInterval(function(){
                xhr.open('GET','/user');
                xhr.onreadystatechange = function(){

                };
            xhr.send()
            },1000)
        </pre>

        <h3>长轮询（comet） </h3>
        <div class="lead" style="margin-left: 10px ">


            <p>
                ajax实现:
                    当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。
                    如果有更新，则进行响应，如果一直没有数据，则到达一定得时间限制（服务器端设置）才返回。客户端JavaScript响应
                    处理函数会在处理完服务器返回的信息后，再次发出请求重新建立连接。

                长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费、
            </p>

            <pre>
                function ajax(){
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET','/user');
                    xhr.onreadystatechange = function(){
                        ajax();
                    }
                    xhr.send();
                }
            </pre>

            <p>
                轮询与长轮询都是基于HTTP的，两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;
                两者都是“被动型服务器”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。
                而理想的模型是"在服务器端数据有了变化后，
                可以主动推送给客户端",这种"主动型"服务器是解决这类问题的很好的方案。Web Sockets就是这样的方案。
            </p>


            <h3>长连接（SSE） </h3>

            <p>
                SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。
                SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。
                而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。

　　              SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。
                并且后面会介绍道，SSE的实现非常简单，并且不需要依赖其他插件。
            </p>

            <h3>WebSocket </h3>
            <p>
                WebSocket是Html5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。
                简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。
                连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。
            </p>

            <h3>
                四种Web即时通信技术比较
            </h3>

            <p>
                从兼容性角度考虑，短轮询>长轮询>长连接SSE>WebSocket；
                从性能方面考虑，WebSocket>长连接SSE>长轮询>短轮询
            </p>

        </div>
    </div>

{% endblock content %}

